{
  "blocks": [
    {
      "id": "3d97a6a7-beb4-4de7-b604-a08c55d702ae",
      "name": "blank",
      "code": "// New p5.js sketch\nfunction setup() {\n  clear();\n}\n\nfunction draw() {\n  clear();\n}"
    },
    {
      "id": "86853f85-4d07-45e7-bb20-4859efe5c804",
      "name": "snow",
      "code": "let flakes = [];\nlet NUM_FLAKES = 100;     // 初期の雪の量\nlet trailMode = false;    // 背景トレイル（残像）表示\nlet wind = 0;             // 現在の風力\nlet windTarget = 0;       // 目標風力（なめらかに追従）\nlet globalTime = 0;\nlet snowHex = \"#fff\";   // 白\nlet sizeScale = 3;       // 雪のサイズスケール 0〜1（連続値）\n\nfunction setup() {\n  createCanvas(windowWidth, windowHeight);\n  pixelDensity(1);\n  initSnow(NUM_FLAKES);\n}\n\nfunction draw() {\n  // 背景処理\n  clear()\n\n  globalTime += deltaTime * 0.001;\n\n  // ゆるいノイズ風（時間で左右に揺れる）\n  const noiseWind = map(noise(globalTime * 0.15), 0, 1, -0.4, 0.4);\n  // マウスでドラッグしているときは風を強める\n  const mouseWind = (mouseIsPressed) ? map(mouseX, 0, width, -1.2, 1.2) : 0;\n\n  windTarget = noiseWind + mouseWind;\n  wind = lerp(wind, windTarget, 0.02);\n\n  // 雪の更新＆描画\n  for (let flake of flakes) {\n    flake.update(wind);\n    flake.draw();\n    flake.wrap();\n  }\n}\n\nfunction windowResized() {\n  resizeCanvas(windowWidth, windowHeight);\n  // 画面サイズが大きく変わったときに端に寄った雪を戻す\n  for (let f of flakes) {\n    f.x = (f.x / max(1, width)) * width;\n    f.y = (f.y / max(1, height)) * height;\n  }\n}\n\nfunction keyPressed() {\n  if (key === 't' || key === 'T') {\n    trailMode = !trailMode;\n  } else if (key === ']') {\n    addFlakes(50);\n  } else if (key === '[') {\n    removeFlakes(50);\n  }\n}\n\nclass Snowflake {\n  constructor() {\n    this.reset(true);\n  }\n\n  reset(spawnAtRandomY = false) {\n    this.x = random(width);\n    this.y = spawnAtRandomY ? random(-height, height) : random(-50, -10);\n\n    this.depth = pow(random(), 2);\n\n    // 連続値で雪のサイズを調整\n    const minSize = 1.0;\n    const maxSize = 4.5;\n    this.size = lerp(minSize, maxSize, this.depth * sizeScale);\n\n    // 大きい雪は少し速く落ちるように\n    const minGravity = 0.4;\n    const maxGravity = 2.1;\n    this.gravity = lerp(minGravity, maxGravity, this.depth * sizeScale);\n\n    this.swayMag = map(this.depth, 0, 1, 0.2, 1.1);\n    this.swaySpeed = random(0.5, 1.2);\n    this.rot = random(TWO_PI);\n    this.rotSpeed = random(-0.02, 0.02);\n    this.noiseSeed = random(1000);\n    this.alpha = map(this.depth, 0, 1, 140, 255);\n\n    this.col = color(snowHex);\n  }\n\n  update(globalWind) {\n    const n = noise(this.noiseSeed, globalTime * this.swaySpeed);\n    const sway = map(n, 0, 1, -this.swayMag, this.swayMag);\n\n    this.x += sway + globalWind * map(this.depth, 0, 1, 0.4, 1.4);\n    this.y += this.gravity * (1 + 0.2 * sin(globalTime + this.noiseSeed));\n    this.rot += this.rotSpeed;\n  }\n\n  draw() {\n    noStroke();\n    fill(red(this.col), green(this.col), blue(this.col), this.alpha);\n\n    push();\n    translate(this.x, this.y);\n    rotate(this.rot);  // 回転は不要なら消しても良い\n    circle(0, 0, this.size);\n    pop();\n  }\n\n  wrap() {\n    if (this.y > height + 10) {\n      this.reset(false);\n      this.y = random(-80, -10);\n      this.x = random(width);\n    }\n    if (this.x < -10) this.x = width + 10;\n    if (this.x > width + 10) this.x = -10;\n  }\n}\n\nfunction initSnow(n) {\n  flakes = [];\n  for (let i = 0; i < n; i++) {\n    flakes.push(new Snowflake());\n  }\n}\n\nfunction addFlakes(n) {\n  for (let i = 0; i < n; i++) flakes.push(new Snowflake());\n}\n\nfunction removeFlakes(n) {\n  flakes.splice(0, min(n, flakes.length));\n}\n\nfunction drawHUD() {\n  const txt = [\n    `flakes: ${nf(flakes.length, 1, 0)}`,\n    `wind: ${wind.toFixed(2)} (drag mouse to blow)`,\n    `'t' trail: ${trailMode ? 'ON' : 'OFF'}`,\n    `']' / '[' : add / remove flakes`\n  ].join('\\n');\n\n  noStroke();\n  fill(255, 180);\n  textSize(12);\n  textAlign(LEFT, TOP);\n  text(txt, 12, 10);\n}"
    },
    {
      "id": "1f9f7984-cebb-41d8-9145-474a66ca12c5",
      "name": "crash",
      "code": "function setup() {\n    createCanvas(windowWidth, windowHeight);\n    pixelDensity(1);\n    startTime = millis();\n    setupRipples();\n}\n\nfunction draw() {\n    clear();\n    drawRipples();\n}\n\nlet ripples = [];\nlet rippleTrailMode = false;\nlet autoSpawn = true;\nlet rippleColor = \"#8EAAD9\";\nlet rippleThickness = 4;\n\nfunction setupRipples() {\n    spawnRipple(width * 0.5, height * 0.5);\n}\n\nfunction drawRipples() {\n    for (let i = ripples.length - 1; i >= 0; i--) {\n        ripples[i].draw(i);\n        const alive = ripples[i].update(i);\n        if (!alive) ripples.splice(i, 1);\n    }\n}\n\nclass Ripple {\n    constructor(x, y, color, thickness) {\n        this.x = x;\n        this.y = y;\n        this.r = 0;\n        this.maxR = max(width, height) * 0.9;\n        this.alpha = 255;\n        this.baseWidth = thickness;\n        this.speed = 15;\n        this.fade = random(1.2, 2.0);\n        this.color = color;\n    }\n    update(i) {\n        this.r += this.speed;\n        this.alpha -= this.fade;\n        return this.alpha > 2 && this.r < this.maxR;\n    }\n    draw(i) {\n        const wobble = sin((frameCount + i * 7) * 0.08) * 0.5;\n        const sw = this.baseWidth + wobble;\n        for (let k = 0; k < 3; k++) {\n            const pr = this.r - k * 10;\n            if (pr <= 0) continue;\n            const a = max(0, this.alpha - k * 40);\n            let c = color(this.color);\n            c.setAlpha(a);\n            stroke(c);\n            strokeWeight(sw - k * 0.25);\n            noFill();\n            ellipse(this.x, this.y, pr * 2, pr * 2);\n        }\n    }\n}\nfunction spawnRipple(x, y) { ripples.push(new Ripple(x, y, rippleColor, rippleThickness)); }\n"
    },
    {
      "id": "cdd781ef-3c52-46bf-acbe-2724ec820dc5",
      "name": "rise",
      "code": "function setup() {\n    createCanvas(windowWidth, windowHeight);\n    pixelDensity(1);\n    startTime = millis();\n    setupShrinkingCircle();\n}\n\nfunction draw() {\n    clear();\n    drawShrinkingCircle();\n}\n\nlet minR = 0;\nlet cycleDuration;\nlet BPM = 172;\nlet Bars = 8; // 8小節で1サイクル\nlet fireMs;   // 発火する時間(ms)\n\nfunction setupShrinkingCircle() {\n    // BPMとBarからサイクル時間を計算\n    let beatDuration = 60000 / BPM; // 1拍(ms)\n    let beatsPerBar = 4;            // 4/4拍子\n    cycleDuration = beatDuration * beatsPerBar * Bars;\n\n    // 8小節中の4小節目から発火\n    let startBar = Bars / 2;\n    fireMs = startBar * beatDuration * beatsPerBar;\n}\n\nfunction drawShrinkingCircle() {\n    let t = (millis() - startTime) % cycleDuration;\n    let maxR = dist(0, 0, width, height); // 画面対角を基準に最大半径を設定\n\n    if (t >= fireMs) {\n        let shrinkProgress = map(t, fireMs, cycleDuration, 0, 1, true);\n        let shrinkR = lerp(maxR, minR, shrinkProgress);\n\n        stroke(\"#8EAAD9\");\n        strokeWeight(1);\n        noFill();\n        ellipse(width / 2, height / 2, shrinkR * 2);\n        ellipse(width / 2, height / 2, shrinkR * 2 + 15);\n    }\n}\n"
    },
    {
      "id": "2dc7cfce-9728-4aa3-be68-02c155d9bec5",
      "name": "intro_hamon",
      "code": "function setup() {\n    setupRipples()\n    startTime = millis();\n    clear()\n}\n\nfunction draw() {\n    drawRipples()\n}\n\nlet ripples = [];\nlet rippleColor = \"#8EAAD9\";\nlet rippleThickness = 0.7;\n\nlet BPM = 172;\nconst STEPS_PER_BAR = 16;\nconst BARS = 8;                        // ★ 8小節\nconst CYCLE_STEPS = STEPS_PER_BAR * BARS; // ★ 128\nlet sixteenthMs;\nlet sequence = [\n    1, 17, 33, 49, 58,\n    65, 81, 97, 115, 122\n];    // 発火ステップ (1..128で指定可)\nlet lastStep = 0;\nlet startMs;\nlet margin = 750;\n\nclass Ripple {\n    constructor(x, y, color, thickness) {\n        this.x = x;\n        this.y = y;\n        this.r = 0;\n        this.maxR = max(width, height) * 0.9;\n        this.alpha = 255;\n        this.baseWidth = thickness;\n        this.speed = 8;\n        this.fade = random(1.2, 2.0);\n        this.color = color;\n    }\n    update(i) {\n        this.r += this.speed;\n        this.alpha -= this.fade;\n        return this.alpha > 2 && this.r < this.maxR;\n    }\n    draw(i) {\n        const wobble = sin((frameCount + i * 7) * 0.08) * 0.5;\n        const sw = this.baseWidth + wobble;\n        for (let k = 0; k < 3; k++) {\n            const pr = this.r - k * 10;\n            if (pr <= 0) continue;\n            const a = max(0, this.alpha - k * 40);\n            let c = color(this.color);\n            c.setAlpha(a);\n            stroke(c);\n            strokeWeight(sw - k * 0.25);\n            noFill();\n            ellipse(this.x, this.y, pr * 2, pr * 2);\n        }\n    }\n}\n\nfunction setupRipples() {\n    createCanvas(windowWidth, windowHeight);\n    noFill();\n    pixelDensity(1);\n    background(20);\n\n    sixteenthMs = 60000 / BPM / 4; // 16分音符の長さ[ms]\n    startMs = millis();\n}\n\nfunction drawRipples() {\n    clear();\n\n    const elapsedMs = (millis() - startMs);\n    const stepFloat = (elapsedMs / sixteenthMs) % CYCLE_STEPS; // 0..<128\n    const currentStep = floor(stepFloat) + 1; // 1..128\n\n    if (currentStep !== lastStep) {\n        let stepsAdvanced = (currentStep - lastStep + CYCLE_STEPS) % CYCLE_STEPS;\n        for (let i = 1; i <= stepsAdvanced; i++) {\n            const s = ((lastStep + i - 1) % CYCLE_STEPS) + 1;\n            if (sequence.includes(s)) {\n                spawnRipple(\n                    random(margin, width - margin),\n                    random(margin, height - margin)\n                );\n            }\n        }\n        lastStep = currentStep;\n    }\n\n    for (let i = ripples.length - 1; i >= 0; i--) {\n        ripples[i].draw(i);\n        const alive = ripples[i].update(i);\n        if (!alive) ripples.splice(i, 1);\n    }\n}\n\nfunction spawnRipple(x, y) {\n    ripples.push(new Ripple(x, y, rippleColor, rippleThickness));\n}\n"
    },
    {
      "id": "fa3c7974-5536-47ed-9249-b4b09ec4b0c4",
      "name": "AB_hamon",
      "code": "function setup() {\n    setupRipples()\n    startTime = millis();\n    clear()\n}\n\nfunction draw() {\n    drawRipples()\n}\n\nlet ripples = [];\nlet rippleColor = \"#8EAAD9\";\nlet rippleThickness = 0.7;\n\nlet BPM = 172;\nconst STEPS_PER_BAR = 16;\nconst BARS = 8;                        // ★ 8小節\nconst CYCLE_STEPS = STEPS_PER_BAR * BARS; // ★ 128\nlet sixteenthMs;\nlet sequence = [\n    3, 19, 35, 51,\n    67, 83, 99, 117,\n];    // 発火ステップ (1..128で指定可)\nlet lastStep = 0;\nlet startMs;\nlet margin = 750;\n\nclass Ripple {\n    constructor(x, y, color, thickness) {\n        this.x = x;\n        this.y = y;\n        this.r = 0;\n        this.maxR = max(width, height) * 0.9;\n        this.alpha = 255;\n        this.baseWidth = thickness;\n        this.speed = 8;\n        this.fade = random(1.2, 2.0);\n        this.color = color;\n    }\n    update(i) {\n        this.r += this.speed;\n        this.alpha -= this.fade;\n        return this.alpha > 2 && this.r < this.maxR;\n    }\n    draw(i) {\n        const wobble = sin((frameCount + i * 7) * 0.08) * 0.5;\n        const sw = this.baseWidth + wobble;\n        for (let k = 0; k < 3; k++) {\n            const pr = this.r - k * 10;\n            if (pr <= 0) continue;\n            const a = max(0, this.alpha - k * 40);\n            let c = color(this.color);\n            c.setAlpha(a);\n            stroke(c);\n            strokeWeight(sw - k * 0.25);\n            noFill();\n            ellipse(this.x, this.y, pr * 2, pr * 2);\n        }\n    }\n}\n\nfunction setupRipples() {\n    createCanvas(windowWidth, windowHeight);\n    noFill();\n    pixelDensity(1);\n    background(20);\n\n    sixteenthMs = 60000 / BPM / 4; // 16分音符の長さ[ms]\n    startMs = millis();\n}\n\nfunction drawRipples() {\n    clear();\n\n    const elapsedMs = (millis() - startMs);\n    const stepFloat = (elapsedMs / sixteenthMs) % CYCLE_STEPS; // 0..<128\n    const currentStep = floor(stepFloat) + 1; // 1..128\n\n    if (currentStep !== lastStep) {\n        let stepsAdvanced = (currentStep - lastStep + CYCLE_STEPS) % CYCLE_STEPS;\n        for (let i = 1; i <= stepsAdvanced; i++) {\n            const s = ((lastStep + i - 1) % CYCLE_STEPS) + 1;\n            if (sequence.includes(s)) {\n                spawnRipple(\n                    random(margin, width - margin),\n                    random(margin, height - margin)\n                );\n            }\n        }\n        lastStep = currentStep;\n    }\n\n    for (let i = ripples.length - 1; i >= 0; i--) {\n        ripples[i].draw(i);\n        const alive = ripples[i].update(i);\n        if (!alive) ripples.splice(i, 1);\n    }\n}\n\nfunction spawnRipple(x, y) {\n    ripples.push(new Ripple(x, y, rippleColor, rippleThickness));\n}\n"
    },
    {
      "id": "563b3e3f-2b71-4807-a903-2c22dc36b84b",
      "name": "intro_A",
      "code": "function setup() {\n    createCanvas(windowWidth, windowHeight);\n    noFill();\n    pixelDensity(1);\n    setupSquares()\n    startTime = millis();\n    clear()\n}\n\nfunction draw() {\n    clear()\n    drawSquares()\n}\n\nlet bpm = 172;\nlet startTime;\nlet baseSize = 20;\nlet targetSize = 70;\nlet sizes = [];\n\nfunction setupSquares() {\n    for (let i = 0; i < 16; i++) sizes[i] = baseSize;\n}\n\nfunction drawSquares() {\n    const secPerBeat = 60 / bpm;       // 1拍\n    const secPer16th = secPerBeat / 4; // 16分音符(1ステップ)\n    const cycleDur = secPerBeat * 4 * 32; // 8小節分の長さ\n    const elapsed = (millis() - startTime) / 1000.0;\n\n    // 1〜128 のグローバルステップ（8小節サイクル）\n    const globalStep = Math.floor((elapsed % cycleDur) / secPer16th) + 1;\n\n    // 現在小節内のステップ(1〜16)\n    const stepInBar = ((globalStep - 1) % 16) + 1;\n\n    // ---- レイアウト計算は元コードのまま ----\n    const maxWidth = Math.min(1000, width);\n    const colsPerRow = 8;\n    const rowGap = 0.001;\n    const spacingX = maxWidth / (colsPerRow + 6);\n    const spacingY = maxWidth / (colsPerRow + 9);\n    const startX = (width - spacingX * colsPerRow) / 2 + spacingX / 2;\n    const startY = height / 2 - spacingX * 0.5;\n\n    for (let i = 0; i < 16; i++) {\n        const isCurrentSquare = (i + 1) === stepInBar;\n        if (isCurrentSquare && beatSteps.includes(globalStep)) {\n            sizes[i] = lerp(sizes[i], targetSize, 0.25);\n        } else {\n            sizes[i] = lerp(sizes[i], baseSize, 0.25);\n        }\n\n        const col = i % colsPerRow;\n        const row = Math.floor(i / colsPerRow);\n        const x = startX + col * spacingX;\n        const y = startY + row * spacingY + (row === 1 ? spacingX * rowGap : 0);\n\n        noFill();\n        stroke(\"#8EAAD9\");\n        strokeWeight(3);\n        rectMode(CENTER);\n        rect(x, y, sizes[i], sizes[i]);\n    }\n}\n\nlet beatSteps = [\n113, 115, 117, 119, 121, 122, 123, 124, 125, 127, 128,\n129, 133, 137, 140, 143,\n145, 149, 153, 156, 159,\n161, 165, 169, 172, 175,\n177, 179, 181, 185, 188, 191, 192,\n193, 197, 201, 204, 207,\n209, 211, 213, 217, 220, 223, 224,\n225, 229, 233, 236, 239,\n241, 243, 245, 248, 249, 250, 251, 252, 253, 255, 256,\n257, 261, 265, 268, 271,\n273, 277, 281, 284, 287,\n289, 293, 297, 300, 303,\n305, 307, 309, 313, 316, 319, 320,\n321, 325, 329, 332, 335,\n337, 341, 345, 348, 351,\n353, 357, 361, 364, 367,\n369, 371, 373, 377, 380, 383, 384,\n385, 389, 393, 396, 399,\n401, 405, 409, 412, 415,\n417, 421, 425, 428, 431,\n433, 435, 437, 441, 444, 447, 448,\n449, 453, 457, 460, 463,\n465, 467, 469, 473, 476, 479, 480,\n481, 485, 489, 492, 495, 496,\n497, 499, 501, 503, 504, 505, 506, 507, 508, 509, 511, 512\n]; // 発火ステップ\n"
    },
    {
      "id": "1fcc7dbc-d9d1-4614-b6b8-3a0d9a1a24c3",
      "name": "B_1",
      "code": "let bpm = 172;\nlet startTime;\nlet baseSize = 20;\nlet targetSize1 = 60; // 上段ターゲット\nlet targetSize2 = 60; // 下段ターゲット\nlet sizes1 = [];\nlet sizes2 = [];\n\n// 上段: 4行×8列 = 32個\nconst rows1 = 4;\nconst cols1 = 8;\nconst totalSquares1 = rows1 * cols1;\n\n// 下段: 1行×8列 = 8個\nconst totalSquares2 = 8;\nconst cols2 = 8;\n\n// 上段: 2小節サイクル（8拍）\nconst beatsPerBar = 4;\nconst barsPerCycle = 2;\nconst beatsPerCycle = beatsPerBar * barsPerCycle; // 8拍\nconst beatToCol = { 1: 0, 4: 3, 7: 6 };\n\nfunction setup() {\n  createCanvas(windowWidth, windowHeight);\n  noFill();\n  pixelDensity(1);\n\n  for (let i = 0; i < totalSquares1; i++) sizes1[i] = baseSize;\n  for (let i = 0; i < totalSquares2; i++) sizes2[i] = baseSize;\n\n  startTime = millis();\n  clear();\n}\n\nfunction draw() {\n  clear();\n\n  const maxWidth = Math.min(1000, width);\n\n  // 上下の間隔\n  const gap = 40;\n\n  // 上段サイズ計算\n  const spacingY1 = maxWidth / (cols1 + 12);\n  const upperHeight = rows1 * spacingY1;\n\n  // 下段サイズ計算（1行）\n  const spacingY2 = maxWidth / (cols2 + 9);\n  const lowerHeight = spacingY2;\n\n  const totalHeight = upperHeight + gap + lowerHeight;\n\n  // 上段の startY（全体を中央に寄せる）\n  const startYUpper = height / 2 - totalHeight / 2 + spacingY1 / 2;\n\n  drawUpperSquares(startYUpper, spacingY1, maxWidth);\n  drawLowerSquares(startYUpper + upperHeight + gap, maxWidth);\n}\n\nfunction drawUpperSquares(startYUpper, spacingY, maxWidth) {\n  const secPerBeat = 60 / bpm;\n  const elapsed = (millis() - startTime) / 1000.0;\n  const cycleDur = secPerBeat * beatsPerCycle / 4;\n  const cyclePos = (elapsed % cycleDur) / cycleDur;\n  const currentBeat = Math.floor(cyclePos * beatsPerCycle) + 1;\n\n  const spacingX = maxWidth / (cols1 + 6);\n  const startX = (width - spacingX * cols1) / 2 + spacingX / 2;\n\n  for (let i = 0; i < totalSquares1; i++) {\n    const col = i % cols1;\n    const row = Math.floor(i / cols1);\n    const x = startX + col * spacingX;\n    const y = startYUpper + row * spacingY;\n\n    noFill();\n    stroke(\"#8EAAD9\");\n    strokeWeight(3);\n\n    if ([0, 3, 6].includes(col)) {\n      // ---- 1,4,7列目 → 四角形（拍で膨らむ） ----\n      if (beatToCol[currentBeat] === col) {\n        sizes1[i] = lerp(sizes1[i], targetSize1, 0.25);\n      } else {\n        sizes1[i] = lerp(sizes1[i], baseSize, 0.25);\n      }\n      rectMode(CENTER);\n      rect(x, y, sizes1[i], sizes1[i]);\n    } else {\n      // ---- その他の列 → 小さな丸 ----\n      ellipseMode(CENTER);\n      ellipse(x, y, baseSize / 4, baseSize / 4);\n    }\n  }\n}\n\nfunction drawLowerSquares(startY, maxWidth) {\n  const secPerBeat = 60 / bpm;\n  const secPer16th = secPerBeat / 4;\n\n  const beatsPerBar = 4;\n  const barsPerCycle = 8;              // ★ 8小節に拡張\n  const beatsPerCycle = beatsPerBar * barsPerCycle; // 32拍\n  const stepsPerCycle = beatsPerCycle * 4;          // 128ステップ\n\n  const cycleDur = secPer16th * stepsPerCycle;      // ★ 128ステップ分の時間\n  const elapsed = (millis() - startTime) / 1000.0;\n\n  const globalStep = Math.floor((elapsed % cycleDur) / secPer16th) + 1; // 1〜128\n\n  const spacingX = maxWidth / (cols2 + 6);\n  const startX = (width - spacingX * cols2) / 2 + spacingX / 2;\n\n  for (let i = 0; i < totalSquares2; i++) {\n    // i は 0〜7。globalStep を 8 で割った余りで位置を決定\n    if (beatSteps.includes(globalStep) && ((globalStep - 1) % cols2) === i) {\n      sizes2[i] = lerp(sizes2[i], targetSize2, 0.25);\n    } else {\n      sizes2[i] = lerp(sizes2[i], baseSize, 0.25);\n    }\n\n    const x = startX + i * spacingX;\n    const y = startY;\n\n    noFill();\n    stroke(\"#8EAAD9\");\n    strokeWeight(3);\n    rectMode(CENTER);\n    rect(x, y, sizes2[i], sizes2[i]);\n  }\n}\n\n// 下段用: 2小節(=16拍=32ステップ)での発火マップ\n// →ここで16拍分にすれば2小節目も反応する\nlet beatSteps = [\n  1, 5, 9, 12, 15,\n  17, 21, 25, 28, 31,\n  33, 37, 41, 44, 47,\n  49, 51, 53, 57, 60, 63, 64,\n  65, 69, 73, 76, 79,\n  81, 85, 89, 92, 95,\n  97, 101, 105, 108, 111,\n  113, 115, 117, 120, 121, 122, 123, 124, 125, 127, 128\n];\n\n"
    },
    {
      "id": "568c9932-2053-435b-acb5-e2ad8bbbe53e",
      "name": "B_2",
      "code": "let bpm = 172;\nlet startTime;\nlet baseSize = 20;\nlet targetSize1 = 60; // 上段ターゲット\nlet targetSize2 = 60; // 下段ターゲット\nlet sizes1 = [];\nlet sizes2 = [];\n\n// 上段: 4行×8列 = 32個\nconst rows1 = 4;\nconst cols1 = 8;\nconst totalSquares1 = rows1 * cols1;\n\n// 下段: 1行×8列 = 8個\nconst totalSquares2 = 8;\nconst cols2 = 8;\n\n// 上段: 2小節サイクル（8拍）\nconst beatsPerBar = 4;\nconst barsPerCycle = 2;\nconst beatsPerCycle = beatsPerBar * barsPerCycle; // 8拍\nconst beatToCol = { 1: 0, 4: 3, 7: 6 };\n\nfunction setup() {\n  createCanvas(windowWidth, windowHeight);\n  noFill();\n  pixelDensity(1);\n\n  for (let i = 0; i < totalSquares1; i++) sizes1[i] = baseSize;\n  for (let i = 0; i < totalSquares2; i++) sizes2[i] = baseSize;\n\n  startTime = millis();\n  clear();\n}\n\nfunction draw() {\n  clear();\n\n  const maxWidth = Math.min(1000, width);\n\n  // 上下の間隔\n  const gap = 40;\n\n  // 上段サイズ計算\n  const spacingY1 = maxWidth / (cols1 + 12);\n  const upperHeight = rows1 * spacingY1;\n\n  // 下段サイズ計算（1行）\n  const spacingY2 = maxWidth / (cols2 + 9);\n  const lowerHeight = spacingY2;\n\n  const totalHeight = upperHeight + gap + lowerHeight;\n\n  // 上段の startY（全体を中央に寄せる）\n  const startYUpper = height / 2 - totalHeight / 2 + spacingY1 / 2;\n\n  drawUpperSquares(startYUpper, spacingY1, maxWidth);\n  drawLowerSquares(startYUpper + upperHeight + gap, maxWidth);\n}\n\nfunction drawUpperSquares(startYUpper, spacingY, maxWidth) {\n  const secPerBeat = 60 / bpm;\n  const elapsed = (millis() - startTime) / 1000.0;\n  const cycleDur = secPerBeat * beatsPerCycle / 4;\n  const cyclePos = (elapsed % cycleDur) / cycleDur;\n  const currentBeat = Math.floor(cyclePos * beatsPerCycle) + 1;\n\n  const spacingX = maxWidth / (cols1 + 6);\n  const startX = (width - spacingX * cols1) / 2 + spacingX / 2;\n\n  for (let i = 0; i < totalSquares1; i++) {\n    const col = i % cols1;\n    const row = Math.floor(i / cols1);\n    const x = startX + col * spacingX;\n    const y = startYUpper + row * spacingY;\n\n    noFill();\n    stroke(\"#8EAAD9\");\n    strokeWeight(3);\n\n    if ([0, 3, 6].includes(col)) {\n      // ---- 1,4,7列目 → 四角形（拍で膨らむ） ----\n      if (beatToCol[currentBeat] === col) {\n        sizes1[i] = lerp(sizes1[i], targetSize1, 0.25);\n      } else {\n        sizes1[i] = lerp(sizes1[i], baseSize, 0.25);\n      }\n      rectMode(CENTER);\n      rect(x, y, sizes1[i], sizes1[i]);\n      rect(x, y, sizes1[i]-10, sizes1[i]-10);\n    } else {\n      // ---- その他の列 → 小さな丸 ----\n      ellipseMode(CENTER);\n      ellipse(x, y, baseSize / 4, baseSize / 4);\n    }\n  }\n}\n\nfunction drawLowerSquares(startY, maxWidth) {\n  const secPerBeat = 60 / bpm;\n  const secPer16th = secPerBeat / 4;\n\n  const beatsPerBar = 4;\n  const barsPerCycle = 8;              // ★ 8小節に拡張\n  const beatsPerCycle = beatsPerBar * barsPerCycle; // 32拍\n  const stepsPerCycle = beatsPerCycle * 4;          // 128ステップ\n\n  const cycleDur = secPer16th * stepsPerCycle;      // ★ 128ステップ分の時間\n  const elapsed = (millis() - startTime) / 1000.0;\n\n  const globalStep = Math.floor((elapsed % cycleDur) / secPer16th) + 1; // 1〜128\n\n  const spacingX = maxWidth / (cols2 + 6);\n  const startX = (width - spacingX * cols2) / 2 + spacingX / 2;\n\n  for (let i = 0; i < totalSquares2; i++) {\n    // i は 0〜7。globalStep を 8 で割った余りで位置を決定\n    if (beatSteps.includes(globalStep) && ((globalStep - 1) % cols2) === i) {\n      sizes2[i] = lerp(sizes2[i], targetSize2, 0.25);\n    } else {\n      sizes2[i] = lerp(sizes2[i], baseSize, 0.25);\n    }\n\n    const x = startX + i * spacingX;\n    const y = startY;\n\n    noFill();\n    stroke(\"#8EAAD9\");\n    strokeWeight(3);\n    rectMode(CENTER);\n    rect(x, y, sizes2[i], sizes2[i]);\n  }\n}\n\n// 下段用: 2小節(=16拍=32ステップ)での発火マップ\n// →ここで16拍分にすれば2小節目も反応する\nlet beatSteps = [\n  1, 5, 9, 12, 15,\n  17, 21, 25, 28, 31,\n  33, 37, 41, 44, 47,\n  49, 51, 53, 57, 60, 63, 64,\n  65, 69, 73, 76, 79,\n  81, 83, 85, 89, 92, 95, 96,\n  97, 99, 101, 103, 105, 107, 109, 111,\n  113, 115, 117, 119, 120, 121, 122, 123, 124, 125, 127, 128\n];\n"
    },
    {
      "id": "c86fa861-806a-4494-b46a-346a4765fe5d",
      "name": "chorus",
      "code": "function setup() {\n    createCanvas(windowWidth, windowHeight);\n    pixelDensity(1);\n    startTime = millis();\n    setupSquares();\n}\n\nfunction draw() {\n    clear();\n    drawSquares();\n    drawCentralCircle();\n}\n\nlet bpm = 172;\nlet startTime;\nlet baseSize = 20;\nlet targetSize = 70;\nlet sizes = [];\n\nfunction setupSquares() {\n    for (let i = 0; i < 16; i++) sizes[i] = baseSize;\n}\n\nfunction drawSquares() {\n    const secPerBeat = 60 / bpm;       // 1拍\n    const secPer16th = secPerBeat / 4; // 16分音符(1ステップ)\n    const cycleDur = secPerBeat * 4 * 8; // 8小節分の長さ\n    const elapsed = (millis() - startTime) / 1000.0;\n\n    // 1〜128 のグローバルステップ（8小節サイクル）\n    const globalStep = Math.floor((elapsed % cycleDur) / secPer16th) + 1;\n\n    // 現在小節内のステップ(1〜16)\n    const stepInBar = ((globalStep - 1) % 16) + 1;\n\n    const maxWidth = Math.min(1000, width);\n    const colsPerRow = 8;\n    const rowGap = 0.001;\n    const spacingX = maxWidth / (colsPerRow + 6);\n    const spacingY = maxWidth / (colsPerRow + 9);\n    const startX = (width - spacingX * colsPerRow) / 2 + spacingX / 2;\n    const startY = height / 2 - spacingX * 0.5;\n\n    for (let i = 0; i < 16; i++) {\n        const isCurrentSquare = (i + 1) === stepInBar;\n        if (isCurrentSquare && beatSteps.includes(globalStep)) {\n            sizes[i] = lerp(sizes[i], targetSize, 0.25);\n        } else {\n            sizes[i] = lerp(sizes[i], baseSize, 0.25);\n        }\n\n        const col = i % colsPerRow;\n        const row = Math.floor(i / colsPerRow);\n        const x = startX + col * spacingX;\n        const y = startY + row * spacingY + (row === 1 ? spacingX * rowGap : 0);\n\n        noFill();\n        stroke(\"#8EAAD9\");\n        strokeWeight(3);\n        rectMode(CENTER);\n        rect(x, y, sizes[i], sizes[i]);\n    }\n}\n\nlet radius = 700;\nlet targetRadius = 500;\n\nfunction drawCentralCircle() {\n    let secPerBeat = 60 / bpm;\n    let secPer16 = secPerBeat / 4;\n    let elapsed = (millis() - startTime) / 1000.0;\n    let step = floor((elapsed % (secPerBeat * 4)) / secPer16) + 1;\n\n    if (beatSteps.includes(step) && abs((elapsed % secPer16)) < 0.05) {\n        targetRadius = 950;\n    } else {\n        targetRadius = 750;\n    }\n    radius = lerp(radius, targetRadius, 0.2);\n\n    noFill();\n    stroke(\"#8EAAD9\");\n    strokeWeight(1);\n    ellipse(width / 2, height / 2, radius, radius);\n    ellipse(width / 2, height / 2, radius + 15, radius + 15);\n}\n\nlet beatSteps = [\n    1, 5, 9, 12, 15,\n    17, 21, 25, 28, 31,\n    33, 37, 41, 44, 47,\n    49, 51, 53, 57, 60, 63, 64,\n    65, 69, 73, 76, 79,\n    81, 85, 89, 92, 95,\n    97, 101, 105, 108, 111,\n    113, 115, 117, 121, 124, 127, 128\n]; // 発火ステップ\n"
    },
    {
      "id": "471ed5a3-6c06-41cc-b1ce-07047c1f2bd0",
      "name": "chorus_after",
      "code": "let bpm = 172;\nlet startTime;\n\nlet positions = [];\nlet alphas = [0, 0, 0, 0];\n\nlet flashInterval = 1; // 拍単位の点滅間隔\nlet nextFlash = 0;     // 次に点滅する絶対時間（秒）\nlet flashingIndex = 0; // 今点滅中の四角\n\nlet squareSize = 90;\nlet gap = 120;\nlet fadeSpeed = 50;\n\nfunction setup() {\n  createCanvas(windowWidth, windowHeight);\n  startTime = millis();\n  updateBasePositions();\n  nextFlash = 0; // 最初に即点滅\n}\n\nfunction draw() {\n  clear(20);\n\n  let secPerBeat = 60 / bpm;\n  let elapsed = (millis() - startTime) / 1000.0;\n\n  // 点滅判定（次の点滅時間に達したらランダムで選ぶ）\n  if (elapsed >= nextFlash) {\n    flashingIndex = floor(random(4)); // 0~3のどれかを点滅\n    alphas[flashingIndex] = 255;\n\n    // 次の点滅タイミングをランダムで1拍か0.5拍に\n    flashInterval = (random() < 0.0) ? 0.25 : 1;\n    nextFlash = elapsed + secPerBeat * flashInterval;\n  }\n\n  // 描画\n  rectMode(CENTER);\n  stroke(\"#8EAAD9\");\n  strokeWeight(3);\n\n  for (let i = 0; i < 4; i++) {\n    if (alphas[i] > 0) fill(142, 170, 217, alphas[i]);\n    else noFill();\n    rect(positions[i].x, positions[i].y, squareSize, squareSize);\n    rect(positions[i].x, positions[i].y, squareSize-15, squareSize-15);\n\n    // フェードアウト\n    alphas[i] = max(alphas[i] - fadeSpeed, 0);\n  }\n}\n\nfunction updateBasePositions() {\n  let cx = width / 2;\n  let cy = height / 2;\n  positions = [\n    createVector(cx - gap / 2, cy - gap / 2),\n    createVector(cx + gap / 2, cy - gap / 2),\n    createVector(cx - gap / 2, cy + gap / 2),\n    createVector(cx + gap / 2, cy + gap / 2)\n  ];\n}\n"
    },
    {
      "id": "15d11d50-bcb2-48cc-8926-d37553aa4a79",
      "name": "chorus_circle",
      "code": "let angle = 0;                // 現在の角度\nlet angularVelocity = 0;      // 回転速度\nlet angularAcceleration = 0;  // 回転加速度\nlet maxAngularSpeed = 0.05;   // 最大速度\nlet direction = 1;            // 回転方向（1: 時計回り, -1: 反時計回り）\nlet radius = 650\n\n// 状態管理\nlet state = \"accelerating\";   // \"accelerating\" / \"cruising\" / \"decelerating\" / \"stopped\"\nlet stateStartTime;\nlet holdDuration;\n\nfunction setup() {\n  createCanvas(windowWidth, windowHeight);\n  stateStartTime = millis();\n  holdDuration = random(2000, 5000); // ランダムに回転し続ける時間\n}\n\nfunction draw() {\n  clear();\n  updateRotation();\n  push();\n  translate(width / 2, height / 2);\n  rotate(angle);\n\n  // -------- 点線の円を描く --------\n  drawDashedCircle(radius, 40); // 半径750, 点の数40\n  drawDashedCircle(radius + 15, 40); // 半径765, 点の数40（外側）\n  pop();\n}\n\nfunction updateRotation() {\n  let now = millis();\n  let elapsed = now - stateStartTime;\n\n  if (state === \"accelerating\") {\n    angularAcceleration = 0.0005 * direction;\n    angularVelocity += angularAcceleration;\n\n    if (abs(angularVelocity) >= maxAngularSpeed) {\n      angularVelocity = maxAngularSpeed * direction;\n      state = \"cruising\";\n      stateStartTime = now;\n      holdDuration = random(1000, 2000); // ランダムに回転時間を設定\n    }\n  } else if (state === \"cruising\") {\n    if (elapsed > holdDuration) {\n      state = \"decelerating\";\n      stateStartTime = now;\n    }\n  } else if (state === \"decelerating\") {\n    angularAcceleration = -0.0005 * direction;\n    angularVelocity += angularAcceleration;\n\n    if ((direction > 0 && angularVelocity <= 0) ||\n        (direction < 0 && angularVelocity >= 0)) {\n      angularVelocity = 0;\n      state = \"stopped\";\n      stateStartTime = now;\n      holdDuration = 0; // 停止時間\n    }\n  } else if (state === \"stopped\") {\n    if (elapsed > holdDuration) {\n      direction *= -1; // 逆回転に切り替え\n      state = \"accelerating\";\n      stateStartTime = now;\n    }\n  }\n\n  angle += angularVelocity;\n}\n\nfunction drawDashedCircle(d, numSegments) {\n  stroke(\"#8EAAD9\");\n  strokeWeight(2);\n  noFill();\n  \n  let step = TWO_PI / numSegments;\n  let dashLength = step * 0.6; // 点の長さ（割合）\n  \n  for (let i = 0; i < TWO_PI; i += step) {\n    arc(0, 0, d, d, i, i + dashLength);\n  }\n}\n"
    },
    {
      "id": "4f0df143-0e21-4206-b790-768b8da19cce",
      "name": "chorus_2",
      "code": "let bpm = 172;\nlet beatSteps = [1, 5, 9, 12, 15];\nlet startTime;\n\nlet positions = [];\nlet targets = [];\nlet transitionAmt = 1;\nlet lastStep = -1;\n\nlet moveSpeed = 0.11;   // 移動スピード\nlet squareSize = 90;   // ★ 四角の一辺の長さ\nlet gap = 120;          // ★ 四角同士の間隔（固定で保つ）\n\nfunction setup() {\n    createCanvas(windowWidth, windowHeight);\n    startTime = millis();\n    updateBasePositions();\n}\n\nfunction draw() {\n    clear();\n\n    let secPerBeat = 60 / bpm;\n    let secPer16 = secPerBeat / 4;\n    let elapsed = (millis() - startTime) / 1000.0;\n\n    let globalStep = floor(elapsed / secPer16) + 1;\n    let stepInBar = ((globalStep - 1) % 16) + 1;\n\n    if (globalStep !== lastStep) {\n        if (beatSteps.includes(stepInBar)) {\n            shuffleTargets();\n            transitionAmt = 0;\n        }\n        lastStep = globalStep;\n    }\n\n    if (transitionAmt < 1) {\n        transitionAmt += moveSpeed;\n    }\n\n    noFill();\n    stroke(\"#8EAAD9\");\n    strokeWeight(3);\n    rectMode(CENTER);\n\n    for (let i = 0; i < 4; i++) {\n        let pos = p5.Vector.lerp(positions[i], targets[i], easeInOut(min(transitionAmt, 1)));\n        rect(pos.x, pos.y, squareSize, squareSize);\n        rect(pos.x, pos.y, squareSize - 15, squareSize - 15);\n    }\n}\n\nfunction updateBasePositions() {\n    let cx = width / 2;\n    let cy = height / 2;\n    let basePos = [\n        createVector(cx - gap / 2, cy - gap / 2),\n        createVector(cx + gap / 2, cy - gap / 2),\n        createVector(cx - gap / 2, cy + gap / 2),\n        createVector(cx + gap / 2, cy + gap / 2)\n    ];\n\n    positions = basePos.map(p => p.copy());\n    targets = basePos.map(p => p.copy());\n}\n\nfunction shuffleTargets() {\n    let cx = width / 2;\n    let cy = height / 2;\n    let basePos = [\n        createVector(cx - gap / 2, cy - gap / 2),\n        createVector(cx + gap / 2, cy - gap / 2),\n        createVector(cx - gap / 2, cy + gap / 2),\n        createVector(cx + gap / 2, cy + gap / 2)\n    ];\n    targets = shuffle(basePos);\n}\n\nfunction easeInOut(t) {\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n}\n"
    },
    {
      "id": "940c8279-101d-4991-84d1-fcafe2ee8fdd",
      "name": "C",
      "code": "let bpm = 172;\nlet startTime;\n\nconst beatsPerBar = 4;\nconst stepsPerBar = 16;\nconst activeSteps = [1, 2, 3, 4, 5, 7, 8];\n\nlet shapes = [];\nlet prevStep = -1;\nlet usedCells = new Set();\n\n// 図形サイズの倍率（0～1で調整）\nlet shapeScale = 0.75;\n// 図形同士の間隔の倍率（1で今までの幅、>1で広く、<1で狭く）\nlet cellSpacing = 0.75;\n\nfunction setup() {\n    createCanvas(windowWidth, windowHeight);\n    noFill();\n    pixelDensity(1);\n    startTime = millis();\n    rectMode(CENTER);\n}\n\nfunction draw() {\n    clear();\n\n    const secPerBeat = 60 / bpm;\n    const secPerStep = secPerBeat / 4;\n    const barDur = secPerStep * stepsPerBar;\n\n    const elapsed = (millis() - startTime) / 1000.0;\n    const barPos = (elapsed % barDur) / barDur;\n    const currentStep = Math.floor(barPos * stepsPerBar) + 1;\n\n    if (currentStep === 1 && prevStep !== 1) {\n        shapes = [];\n        usedCells.clear();\n    }\n\n    if (currentStep !== prevStep) {\n        if (activeSteps.includes(currentStep)) {\n            spawnShape(shapeScale, cellSpacing);\n        }\n    }\n\n    // === 囲み正方形 ===\n    const baseSize = min(width, height) * 0.4;\n    const gridSizeReal = baseSize * cellSpacing;\n    const centerX = width / 2;\n    const centerY = height / 2;\n\n    // 単色半透明\n    fill(color(142, 170, 217, 4)); // rgbaで透明度50\n    // noStroke();\n    strokeWeight(0.5)\n    rect(centerX, centerY, gridSizeReal, gridSizeReal);\n    rect(centerX, centerY, gridSizeReal + 15, gridSizeReal + 15);\n\n    // --- グラデーション例 ---\n    push();\n    for (let i = 0; i < gridSizeReal; i++) {\n        let inter = map(i, 0, gridSizeReal, 0, 1);\n        let c = lerpColor(color(142, 170, 217, 5), color(142, 170, 217, 2), inter); // 上:かなり薄い 下:薄い\n        stroke(c);\n        line(centerX - gridSizeReal / 2, centerY - gridSizeReal / 2 + i, centerX + gridSizeReal / 2, centerY - gridSizeReal / 2 + i);\n    }\n    pop();\n\n    // === Shape 描画 ===\n    for (let s of shapes) {\n        s.draw();\n    }\n\n    prevStep = currentStep;\n}\n\nfunction spawnShape(scale, spacing) {\n    const gridSize = 4;\n    const baseSize = min(width, height) * 0.4;\n    const cellSize = (baseSize / gridSize) * spacing;\n    const startX = width / 2 - (cellSize * gridSize) / 2 + cellSize / 2;\n    const startY = height / 2 - (cellSize * gridSize) / 2 + cellSize / 2;\n\n    let gx, gy, key;\n    let attempts = 0;\n    do {\n        gx = floor(random(gridSize));\n        gy = floor(random(gridSize));\n        key = gx + \",\" + gy;\n        attempts++;\n        if (attempts > 50) return;\n    } while (usedCells.has(key));\n\n    usedCells.add(key);\n\n    const x = startX + gx * cellSize;\n    const y = startY + gy * cellSize;\n\n    const types = [\"square\", \"circle\", \"triangle\", \"diamond\"];\n    const type = random(types);\n\n    shapes.push(new Shape(x, y, cellSize * scale, type));\n}\n\nclass Shape {\n    constructor(x, y, size, type) {\n        this.x = x;\n        this.y = y;\n        this.size = size;\n        this.type = type;\n    }\n\n    draw() {\n        stroke(\"#8EAAD9\");\n        strokeWeight(2);\n        noFill();\n        push();\n        translate(this.x, this.y);\n\n        const inset = min(10, this.size * 0.2); // 二重線の内側オフセット（サイズに合わせて制限）\n\n        switch (this.type) {\n            case \"square\":\n                rectMode(CENTER);\n                rect(0, 0, this.size, this.size);\n                rect(0, 0, max(0, this.size - inset), max(0, this.size - inset));\n                break;\n\n            case \"circle\":\n                ellipse(0, 0, this.size, this.size);\n                ellipse(0, 0, max(0, this.size - inset), max(0, this.size - inset));\n                break;\n\n            case \"triangle\":\n                // 正三角形を原点中心で描く（外側）\n                drawCenteredTriangle(this.size);\n                // 内側（少し小さく）\n                drawCenteredTriangle(max(0, this.size - inset));\n                break;\n\n            case \"diamond\":\n                // 外側\n                beginShape();\n                vertex(0, -this.size / 2);\n                vertex(this.size / 2, 0);\n                vertex(0, this.size / 2);\n                vertex(-this.size / 2, 0);\n                endShape(CLOSE);\n                // 内側（少し小さく）\n                beginShape();\n                const s2 = max(0, this.size - inset);\n                vertex(0, -s2 / 2);\n                vertex(s2 / 2, 0);\n                vertex(0, s2 / 2);\n                vertex(-s2 / 2, 0);\n                endShape(CLOSE);\n                break;\n        }\n        pop();\n    }\n}\n\n// ヘルパー：原点中心の正三角形を描く（size = 辺の長さ）\nfunction drawCenteredTriangle(size) {\n    if (size <= 0) return;\n    // 正三角形の外接円半径 R = side / sqrt(3)\n    const R = size / Math.sqrt(3);\n    beginShape();\n    for (let i = 0; i < 3; i++) {\n        // -PI/2 (上向き), 次に 120度 単位で回す\n        const ang = -PI / 2 + i * (TWO_PI / 3);\n        vertex(cos(ang) * R, sin(ang) * R);\n    }\n    endShape(CLOSE);\n}\n"
    },
    {
      "id": "90b716ed-989a-4950-ad9c-dd9810ab321b",
      "name": "C_Circle",
      "code": "function setup() {\n    createCanvas(windowWidth, windowHeight);\n    pixelDensity(1);\n    startTime = millis();\n}\n\nfunction draw() {\n    clear();\n    drawCentralCircle();\n}\n\nlet bpm = 172;\nlet beatSteps = [1, 4, 7, 9, 12, 15];\nlet startTime;\nlet baseSize = 20;\nlet targetSize = 70;\nlet sizes = [];\nlet radius = 700;\nlet targetRadius = 500;\n\nfunction drawCentralCircle() {\n    let secPerBeat = 60 / bpm;\n    let secPer16 = secPerBeat / 4;\n    let elapsed = (millis() - startTime) / 1000.0;\n    let step = floor((elapsed % (secPerBeat * 4)) / secPer16) + 1;\n\n    if (beatSteps.includes(step) && abs((elapsed % secPer16)) < 0.05) {\n        targetRadius = 950;\n    } else {\n        targetRadius = 750;\n    }\n    radius = lerp(radius, targetRadius, 0.2);\n\n    noFill();\n    stroke(\"#8EAAD9\");\n    strokeWeight(1);\n    ellipse(width / 2, height / 2, radius, radius);\n    ellipse(width / 2, height / 2, radius + 15, radius + 15);\n}\n\n"
    },
    {
      "id": "984c49f1-93b3-45e1-be23-c2ecb61cf9a6",
      "name": "C2_1",
      "code": "let bpm = 172;\nlet startTime;\nlet baseSize = 20;\nlet targetSize1 = 60; // 上段ターゲット\nlet targetSize2 = 60; // 下段ターゲット\nlet sizes1 = [];\nlet sizes2 = [];\n\n// 上段: 4行×8列 = 32個\nconst rows1 = 4;\nconst cols1 = 8;\nconst totalSquares1 = rows1 * cols1;\n\n// 下段: 1行×8列 = 8個\nconst totalSquares2 = 8;\nconst cols2 = 8;\n\n// 上段: 2小節サイクル（8拍）\nconst beatsPerBar = 4;\nconst barsPerCycle = 2;\nconst beatsPerCycle = beatsPerBar * barsPerCycle; // 8拍\nconst beatToCol = { 1: 0, 4: 3, 7: 6 };\n\nfunction setup() {\n  createCanvas(windowWidth, windowHeight);\n  noFill();\n  pixelDensity(1);\n\n  for (let i = 0; i < totalSquares1; i++) sizes1[i] = baseSize;\n  for (let i = 0; i < totalSquares2; i++) sizes2[i] = baseSize;\n\n  startTime = millis();\n  clear();\n}\n\nfunction draw() {\n  clear();\n\n  const maxWidth = Math.min(1000, width);\n\n  // 上下の間隔\n  const gap = 40;\n\n  // 上段サイズ計算\n  const spacingY1 = maxWidth / (cols1 + 12);\n  const upperHeight = rows1 * spacingY1;\n\n  // 下段サイズ計算（1行）\n  const spacingY2 = maxWidth / (cols2 + 9);\n  const lowerHeight = spacingY2;\n\n  const totalHeight = upperHeight + gap + lowerHeight;\n\n  // 上段の startY（全体を中央に寄せる）\n  const startYUpper = height / 2 - totalHeight / 2 + spacingY1 / 2;\n\n  drawUpperSquares(startYUpper, spacingY1, maxWidth);\n  drawLowerSquares(startYUpper + upperHeight + gap, maxWidth);\n}\n\nfunction drawUpperSquares(startYUpper, spacingY, maxWidth) {\n  const secPerBeat = 60 / bpm;\n  const elapsed = (millis() - startTime) / 1000.0;\n  const cycleDur = secPerBeat * beatsPerCycle / 4;\n  const cyclePos = (elapsed % cycleDur) / cycleDur;\n  const currentBeat = Math.floor(cyclePos * beatsPerCycle) + 1;\n\n  const spacingX = maxWidth / (cols1 + 6);\n  const startX = (width - spacingX * cols1) / 2 + spacingX / 2;\n\n  for (let i = 0; i < totalSquares1; i++) {\n    const col = i % cols1;\n    const row = Math.floor(i / cols1);\n    const x = startX + col * spacingX;\n    const y = startYUpper + row * spacingY;\n\n    noFill();\n    stroke(\"#8EAAD9\");\n    strokeWeight(3);\n\n    if ([0, 3, 6].includes(col)) {\n      // ---- 1,4,7列目 → 四角形（拍で膨らむ） ----\n      if (beatToCol[currentBeat] === col) {\n        sizes1[i] = lerp(sizes1[i], targetSize1, 0.25);\n      } else {\n        sizes1[i] = lerp(sizes1[i], baseSize, 0.25);\n      }\n      rectMode(CENTER);\n      rect(x, y, sizes1[i], sizes1[i]);\n    } else {\n      // ---- その他の列 → 小さな丸 ----\n      ellipseMode(CENTER);\n      ellipse(x, y, baseSize / 4, baseSize / 4);\n    }\n  }\n}\n\nfunction drawLowerSquares(startY, maxWidth) {\n  const secPerBeat = 60 / bpm;\n  const secPer16th = secPerBeat / 4;\n\n  const beatsPerBar = 4;\n  const barsPerCycle = 8;              // ★ 8小節に拡張\n  const beatsPerCycle = beatsPerBar * barsPerCycle; // 32拍\n  const stepsPerCycle = beatsPerCycle * 4;          // 128ステップ\n\n  const cycleDur = secPer16th * stepsPerCycle;      // ★ 128ステップ分の時間\n  const elapsed = (millis() - startTime) / 1000.0;\n\n  const globalStep = Math.floor((elapsed % cycleDur) / secPer16th) + 1; // 1〜128\n\n  const spacingX = maxWidth / (cols2 + 6);\n  const startX = (width - spacingX * cols2) / 2 + spacingX / 2;\n\n  for (let i = 0; i < totalSquares2; i++) {\n    // i は 0〜7。globalStep を 8 で割った余りで位置を決定\n    if (beatSteps.includes(globalStep) && ((globalStep - 1) % cols2) === i) {\n      sizes2[i] = lerp(sizes2[i], targetSize2, 0.25);\n    } else {\n      sizes2[i] = lerp(sizes2[i], baseSize, 0.25);\n    }\n\n    const x = startX + i * spacingX;\n    const y = startY;\n\n    noFill();\n    stroke(\"#8EAAD9\");\n    strokeWeight(3);\n    rectMode(CENTER);\n    rect(x, y, sizes2[i], sizes2[i]);\n  }\n}\n\nlet beatSteps = [\n  1, 5, 9, 12, 15,\n  17, 21, 25, 28, 31,\n  33, 37, 41, 44, 47,\n  49, 51, 53, 57, 60, 63, 64,\n  65, 69, 73, 76, 79,\n  81, 85, 89, 92, 95,\n  97, 101, 105, 108, 111,\n  113, 115, 117, 121, 124, 127, 128\n];\n"
    },
    {
      "id": "8d513a20-1d87-45b3-a607-8d23a126a89f",
      "name": "=================",
      "code": "// New p5.js sketch\nfunction setup() {\n  createCanvas(400, 400);\n}\n\nfunction draw() {\n  background(220);\n}"
    },
    {
      "name": "Circle",
      "code": "function setup() {\n    createCanvas(windowWidth, windowHeight);\n    background(0, 100, 200);\n}\nfunction draw() {\n    ellipse(width/2, height/2, 100, 100);\n}",
      "id": "204dccbe-0050-44a3-a8df-b4882ff97db1"
    }
  ],
  "selected_code_id": "3d97a6a7-beb4-4de7-b604-a08c55d702ae"
}